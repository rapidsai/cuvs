#!/bin/bash

# SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION.
# SPDX-License-Identifier: Apache-2.0

# This script is a wrapper for clang-tidy that may be used with pre-commit.
#
# Two modes of operation:
# 1. Full mode: requires a compilation database (compile_commands.json)
#    generated by cmake. Runs all configured clang-tidy checks on .cpp files.
# 2. Fallback (syntax-only) mode: when no compilation database is found,
#    runs a reduced set of purely syntactical checks on .cpp/.hpp/.h/.cuh files
#    using auto-detected include paths. Checks that require full AST analysis
#    (like readability-identifier-naming) are skipped in this mode.
#
# Only .cpp files are checked in full mode (CUDA .cu files require special
# handling with clang, see run-clang-tidy.py for the full CUDA-aware runner).
#
# Usage:
# bash run-clang-tidy-hook.sh infile [infile ...]

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
if [ -z "${REPO_ROOT}" ]; then
    echo "Warning: not inside a git repository. Skipping clang-tidy."
    exit 0
fi

BUILD_DIR="${REPO_ROOT}/cpp/build"
CDB="${BUILD_DIR}/compile_commands.json"

# Determine clang-tidy binary
CLANG_TIDY="${CLANG_TIDY:-clang-tidy}"
if ! command -v "${CLANG_TIDY}" &>/dev/null; then
    echo "Warning: ${CLANG_TIDY} not found. Skipping clang-tidy."
    exit 0
fi

HEADER_FILTER=".*cuvs/cpp/(src|include|bench|tests)/.*\.(cuh|h|hpp)$"
FAILED=0

# ---- Full mode: compilation database available ----
if [ -f "${CDB}" ]; then
    for file in "$@"; do
        case "${file}" in
            *.cpp) ;;
            *) continue ;;
        esac

        # Resolve to absolute path
        if [[ "${file}" != /* ]]; then
            file="${REPO_ROOT}/${file}"
        fi

        # Check if the file is in the compilation database
        if ! grep -q "\"${file}\"" "${CDB}" 2>/dev/null; then
            continue
        fi

        OUTPUT=$("${CLANG_TIDY}" -p "${BUILD_DIR}" \
            -header-filter="${HEADER_FILTER}" \
            --quiet \
            "${file}" 2>&1)

        VIOLATIONS=$(echo "${OUTPUT}" | grep -E '\[(modernize-|google-|readability-)' || true)

        if [ -n "${VIOLATIONS}" ]; then
            echo "clang-tidy issues in ${file}:"
            echo "${VIOLATIONS}"
            echo ""
            FAILED=1
        fi
    done
    exit ${FAILED}
fi

# ---- Fallback mode: no compilation database ----

# Auto-detect include paths
EXTRA_ARGS=(-std=c++17 -x c++)

# Project includes
EXTRA_ARGS+=("-I${REPO_ROOT}/cpp/include")

# Build-time generated includes (if available from a previous build)
if [ -d "${BUILD_DIR}/include" ]; then
    EXTRA_ARGS+=("-I${BUILD_DIR}/include")
fi

# CCCL (thrust/cub/libcudacxx) from build deps
if [ -d "${BUILD_DIR}/_deps/cccl-src" ]; then
    for sub in thrust cub; do
        if [ -d "${BUILD_DIR}/_deps/cccl-src/${sub}" ]; then
            EXTRA_ARGS+=("-I${BUILD_DIR}/_deps/cccl-src/${sub}")
        fi
    done
    if [ -d "${BUILD_DIR}/_deps/cccl-src/libcudacxx/include" ]; then
        EXTRA_ARGS+=("-I${BUILD_DIR}/_deps/cccl-src/libcudacxx/include")
    fi
fi

# Other build deps
for dep_dir in dlpack-src nvidiacutlass-src cuco-src diskann-src; do
    if [ -d "${BUILD_DIR}/_deps/${dep_dir}/include" ]; then
        EXTRA_ARGS+=("-I${BUILD_DIR}/_deps/${dep_dir}/include")
    fi
done
if [ -d "${BUILD_DIR}/_deps/nvidiacutlass-build/include" ]; then
    EXTRA_ARGS+=("-I${BUILD_DIR}/_deps/nvidiacutlass-build/include")
fi

# CUDA toolkit (from nvcc location or CUDA_HOME)
CUDA_HOME="${CUDA_HOME:-}"
if [ -z "${CUDA_HOME}" ] && command -v nvcc &>/dev/null; then
    CUDA_HOME=$(dirname "$(dirname "$(which nvcc)")")
fi
if [ -n "${CUDA_HOME}" ]; then
    # Standard CUDA toolkit layout
    for cuda_inc in \
        "${CUDA_HOME}/targets/x86_64-linux/include" \
        "${CUDA_HOME}/targets/aarch64-linux/include" \
        "${CUDA_HOME}/include"; do
        if [ -d "${cuda_inc}" ] && [ -f "${cuda_inc}/cuda_fp16.h" ]; then
            EXTRA_ARGS+=("-isystem" "${cuda_inc}")
            break
        fi
    done
fi

# Conda/pip-installed raft, rmm (from CONDA_PREFIX or same prefix as nvcc)
for prefix in "${CONDA_PREFIX}" "${CUDA_HOME}"; do
    if [ -n "${prefix}" ] && [ -d "${prefix}/include/raft" ]; then
        EXTRA_ARGS+=("-isystem" "${prefix}/include")
        break
    fi
done

# Feature flags
EXTRA_ARGS+=(-DCUVS_BUILD_CAGRA_HNSWLIB -DCUVS_BUILD_MG_ALGOS)

# Reduced check set: only syntactical checks that don't need deep AST analysis.
# Excluded: readability-identifier-naming (needs full type resolution),
#           google-build-* (needs full include graph),
#           modernize-use-auto (needs type inference).
SYNTAX_CHECKS="-*"
SYNTAX_CHECKS+=",modernize-use-nullptr"
SYNTAX_CHECKS+=",modernize-use-using"
SYNTAX_CHECKS+=",modernize-use-trailing-return-type"
SYNTAX_CHECKS+=",modernize-use-nodiscard"
SYNTAX_CHECKS+=",modernize-use-equals-default"
SYNTAX_CHECKS+=",modernize-use-override"
SYNTAX_CHECKS+=",google-readability-todo"
SYNTAX_CHECKS+=",google-readability-casting"
SYNTAX_CHECKS+=",google-readability-braces-around-statements"
SYNTAX_CHECKS+=",google-explicit-constructor"

echo "Note: No compilation database found. Running syntax-only clang-tidy checks."

for file in "$@"; do
    # Process .cpp, .hpp, .h, .cuh files
    case "${file}" in
        *.cpp | *.hpp | *.h | *.cuh) ;;
        *) continue ;;
    esac

    # Resolve to absolute path
    if [[ "${file}" != /* ]]; then
        file="${REPO_ROOT}/${file}"
    fi

    # Skip files outside the project source tree
    case "${file}" in
        */cpp/include/* | */cpp/src/* | */cpp/bench/* | */cpp/tests/* | */c/src/*) ;;
        *) continue ;;
    esac

    OUTPUT=$("${CLANG_TIDY}" \
        --checks="${SYNTAX_CHECKS}" \
        --quiet \
        "${file}" \
        -- "${EXTRA_ARGS[@]}" 2>&1)

    # Filter: only report clang-tidy check violations, not clang diagnostics
    VIOLATIONS=$(echo "${OUTPUT}" | grep -E '\[(modernize-|google-|readability-)' || true)

    if [ -n "${VIOLATIONS}" ]; then
        echo "clang-tidy issues in ${file}:"
        echo "${VIOLATIONS}"
        echo ""
        FAILED=1
    fi
done

exit ${FAILED}
