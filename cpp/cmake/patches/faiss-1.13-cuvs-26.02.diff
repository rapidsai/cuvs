diff --git a/faiss/gpu/GpuDistance.cu b/faiss/gpu/GpuDistance.cu
index c82c73e7d..2f330b523 100644
--- a/faiss/gpu/GpuDistance.cu
+++ b/faiss/gpu/GpuDistance.cu
@@ -43,7 +43,6 @@
 #include <raft/core/operators.hpp>
 #include <raft/core/temporary_device_buffer.hpp>
 #include <raft/linalg/unary_op.cuh>
-#include <raft/neighbors/brute_force.cuh>
 #endif

 namespace faiss {
@@ -239,7 +238,7 @@ void bfKnn(GpuResourcesProvider* prov, const GpuDistanceParams& args) {
     if (should_use_cuvs(args) && args.queriesRowMajor == args.vectorsRowMajor &&
         args.outIndicesType == IndicesDataType::I64 &&
         args.vectorType == DistanceDataType::F32 && args.k > 0) {
-        cuvsDistanceType distance = metricFaissToCuvs(args.metric, false);
+        auto distance = metricFaissToCuvs(args.metric, false);

         auto resImpl = prov->getResources();
         auto res = resImpl.get();
diff --git a/faiss/gpu/GpuResources.h b/faiss/gpu/GpuResources.h
index c0c851a89..61d9d4dbe 100644
--- a/faiss/gpu/GpuResources.h
+++ b/faiss/gpu/GpuResources.h
@@ -33,7 +33,7 @@

 #if defined USE_NVIDIA_CUVS
 #include <raft/core/device_resources.hpp>
-#include <rmm/mr/device/device_memory_resource.hpp>
+#include <rmm/mr/device_memory_resource.hpp>
 #endif

 namespace faiss {
diff --git a/faiss/gpu/StandardGpuResources.cpp b/faiss/gpu/StandardGpuResources.cpp
index 649b7cb5c..622443044 100644
--- a/faiss/gpu/StandardGpuResources.cpp
+++ b/faiss/gpu/StandardGpuResources.cpp
@@ -23,9 +23,9 @@

 #if defined USE_NVIDIA_CUVS
 #include <raft/core/device_resources.hpp>
-#include <rmm/mr/device/managed_memory_resource.hpp>
-#include <rmm/mr/device/per_device_resource.hpp>
-#include <rmm/mr/host/pinned_memory_resource.hpp>
+#include <rmm/mr/managed_memory_resource.hpp>
+#include <rmm/mr/per_device_resource.hpp>
+#include <rmm/mr/pinned_host_memory_resource.hpp>
 #include <memory>
 #endif

@@ -93,7 +93,7 @@ StandardGpuResourcesImpl::StandardGpuResourcesImpl()
         :
 #if defined USE_NVIDIA_CUVS
           mmr_(new rmm::mr::managed_memory_resource),
-          pmr_(new rmm::mr::pinned_memory_resource),
+          pmr_(new rmm::mr::pinned_host_memory_resource),
 #endif
           pinnedMemAlloc_(nullptr),
           pinnedMemAllocSize_(0),
@@ -164,7 +164,7 @@ StandardGpuResourcesImpl::~StandardGpuResourcesImpl() {

     if (pinnedMemAlloc_) {
 #if defined USE_NVIDIA_CUVS
-        pmr_->deallocate(pinnedMemAlloc_, pinnedMemAllocSize_);
+        pmr_->deallocate_sync(pinnedMemAlloc_, pinnedMemAllocSize_);
 #else
         auto err = cudaFreeHost(pinnedMemAlloc_);
         FAISS_ASSERT_FMT(
@@ -350,7 +350,7 @@ void StandardGpuResourcesImpl::initializeForDevice(int device) {
         // pinned memory allocation
         if (defaultStreams_.empty() && pinnedMemSize_ > 0) {
             try {
-                pinnedMemAlloc_ = pmr_->allocate(pinnedMemSize_);
+                pinnedMemAlloc_ = pmr_->allocate_sync(pinnedMemSize_);
             } catch (const std::bad_alloc& rmm_ex) {
                 FAISS_THROW_MSG("CUDA memory allocation error");
             }
@@ -549,7 +549,7 @@ void* StandardGpuResourcesImpl::allocMemory(const AllocRequest& req) {
             rmm::mr::device_memory_resource* current_mr =
                     rmm::mr::get_per_device_resource(
                             rmm::cuda_device_id{adjReq.device});
-            p = current_mr->allocate_async(adjReq.size, adjReq.stream);
+            p = current_mr->allocate(adjReq.stream, adjReq.size);
             adjReq.mr = current_mr;
         } catch (const std::bad_alloc& rmm_ex) {
             FAISS_THROW_MSG("CUDA memory allocation error");
@@ -584,7 +584,7 @@ void* StandardGpuResourcesImpl::allocMemory(const AllocRequest& req) {
             // TODO: change this to use the current device resource once RMM has
             // a way to retrieve a "guaranteed" managed memory resource for a
             // device.
-            p = mmr_->allocate_async(adjReq.size, adjReq.stream);
+            p = mmr_->allocate(adjReq.stream, adjReq.size);
             adjReq.mr = mmr_.get();
         } catch (const std::bad_alloc& rmm_ex) {
             FAISS_THROW_MSG("CUDA memory allocation error");
@@ -648,7 +648,7 @@ void StandardGpuResourcesImpl::deallocMemory(int device, void* p) {
             req.space == MemorySpace::Device ||
             req.space == MemorySpace::Unified) {
 #if defined USE_NVIDIA_CUVS
-        req.mr->deallocate_async(p, req.size, req.stream);
+        req.mr->deallocate(req.stream, p, req.size);
 #else
         auto err = cudaFree(p);
         FAISS_ASSERT_FMT(
diff --git a/faiss/gpu/StandardGpuResources.h b/faiss/gpu/StandardGpuResources.h
index f23ca19d8..3ba606606 100644
--- a/faiss/gpu/StandardGpuResources.h
+++ b/faiss/gpu/StandardGpuResources.h
@@ -25,7 +25,8 @@

 #if defined USE_NVIDIA_CUVS
 #include <raft/core/device_resources.hpp>
-#include <rmm/mr/host/pinned_memory_resource.hpp>
+#include <rmm/mr/device_memory_resource.hpp>
+#include <rmm/mr/pinned_host_memory_resource.hpp>
 #endif

 #include <faiss/gpu/GpuResources.h>
@@ -172,8 +173,8 @@ class StandardGpuResourcesImpl : public GpuResources {
     // managed_memory_resource
     std::unique_ptr<rmm::mr::device_memory_resource> mmr_;

-    // pinned_memory_resource
-    std::unique_ptr<rmm::mr::host_memory_resource> pmr_;
+    // pinned_host_memory_resource
+    std::unique_ptr<rmm::mr::pinned_host_memory_resource> pmr_;
 #endif

     /// Pinned memory allocation for use with this GPU
diff --git a/faiss/gpu/impl/CuvsFlatIndex.cu b/faiss/gpu/impl/CuvsFlatIndex.cu
index 15cf427cf..d1669831c 100644
--- a/faiss/gpu/impl/CuvsFlatIndex.cu
+++ b/faiss/gpu/impl/CuvsFlatIndex.cu
@@ -31,7 +31,6 @@
 #include <cuvs/neighbors/brute_force.hpp>
 #include <raft/core/device_mdspan.hpp>
 #include <raft/core/logger.hpp>
-#include <raft/distance/distance_types.hpp>
 #include <raft/linalg/unary_op.cuh>

 namespace faiss {
@@ -92,7 +91,7 @@ void CuvsFlatIndex::query(
                 outDistances.getSize(0),
                 outDistances.getSize(1));

-        cuvsDistanceType distance = metricFaissToCuvs(metric, exactDistance);
+        auto distance = metricFaissToCuvs(metric, exactDistance);

         std::optional<raft::device_vector_view<const float, int64_t>>
                 norms_view = raft::make_device_vector_view(
diff --git a/faiss/gpu/impl/CuvsIVFPQ.cu b/faiss/gpu/impl/CuvsIVFPQ.cu
index 1e2fef225..e9781144f 100644
--- a/faiss/gpu/impl/CuvsIVFPQ.cu
+++ b/faiss/gpu/impl/CuvsIVFPQ.cu
@@ -149,22 +149,60 @@ void CuvsIVFPQ::updateQuantizer(Index* quantizer) {
             // as float32 and store locally
             gpuData->reconstruct(0, gpuData->getSize(), centroids);

-            cuvs::neighbors::ivf_pq::helpers::set_centers(
-                    raft_handle,
-                    cuvs_index.get(),
+            auto mutable_centers_view =
+                    raft::make_device_matrix_view<float, uint32_t>(
+                            const_cast<float*>(
+                                    cuvs_index->centers().data_handle()),
+                            numLists_,
+                            cuvs_index->centers().extent(1));
+            auto mutable_centers_rot_view =
                     raft::make_device_matrix_view<float, uint32_t>(
-                            centroids.data(), numLists_, dim_));
+                            const_cast<float*>(
+                                    cuvs_index->centers_rot().data_handle()),
+                            cuvs_index->centers_rot().extent(0),
+                            cuvs_index->centers_rot().extent(1));
+
+            cuvs::neighbors::ivf_pq::helpers::pad_centers_with_norms(
+                    raft_handle,
+                    raft::make_const_mdspan(
+                            raft::make_device_matrix_view<float, uint32_t>(
+                                    centroids.data(), numLists_, dim_)),
+                    mutable_centers_view);
+            cuvs::neighbors::ivf_pq::helpers::rotate_padded_centers(
+                    raft_handle,
+                    cuvs_index->centers(),
+                    cuvs_index->rotation_matrix(),
+                    mutable_centers_rot_view);
         } else {
             /// No reconstruct needed since the centers are already in float32
             // The FlatIndex keeps its data in float32, so we can merely
             // reference it
             auto centroids = gpuData->getVectorsFloat32Ref();

-            cuvs::neighbors::ivf_pq::helpers::set_centers(
-                    raft_handle,
-                    cuvs_index.get(),
+            auto mutable_centers_view =
                     raft::make_device_matrix_view<float, uint32_t>(
-                            centroids.data(), numLists_, dim_));
+                            const_cast<float*>(
+                                    cuvs_index->centers().data_handle()),
+                            numLists_,
+                            cuvs_index->centers().extent(1));
+            auto mutable_centers_rot_view =
+                    raft::make_device_matrix_view<float, uint32_t>(
+                            const_cast<float*>(
+                                    cuvs_index->centers_rot().data_handle()),
+                            cuvs_index->centers_rot().extent(0),
+                            cuvs_index->centers_rot().extent(1));
+
+            cuvs::neighbors::ivf_pq::helpers::pad_centers_with_norms(
+                    raft_handle,
+                    raft::make_const_mdspan(
+                            raft::make_device_matrix_view<float, uint32_t>(
+                                    centroids.data(), numLists_, dim_)),
+                    mutable_centers_view);
+            cuvs::neighbors::ivf_pq::helpers::rotate_padded_centers(
+                    raft_handle,
+                    cuvs_index->centers(),
+                    cuvs_index->rotation_matrix(),
+                    mutable_centers_rot_view);
         }
     } else {
         DeviceTensor<float, 2, true> centroids(
@@ -180,11 +218,30 @@ void CuvsIVFPQ::updateQuantizer(Index* quantizer) {

         centroids.copyFrom(vecs, stream);

-        cuvs::neighbors::ivf_pq::helpers::set_centers(
-                raft_handle,
-                cuvs_index.get(),
+        // Create mutable views for output parameters
+        auto mutable_centers_view =
                 raft::make_device_matrix_view<float, uint32_t>(
-                        centroids.data(), numLists_, dim_));
+                        const_cast<float*>(cuvs_index->centers().data_handle()),
+                        numLists_,
+                        cuvs_index->centers().extent(1));
+        auto mutable_centers_rot_view =
+                raft::make_device_matrix_view<float, uint32_t>(
+                        const_cast<float*>(
+                                cuvs_index->centers_rot().data_handle()),
+                        cuvs_index->centers_rot().extent(0),
+                        cuvs_index->centers_rot().extent(1));
+
+        cuvs::neighbors::ivf_pq::helpers::pad_centers_with_norms(
+                raft_handle,
+                raft::make_const_mdspan(
+                        raft::make_device_matrix_view<float, uint32_t>(
+                                centroids.data(), numLists_, dim_)),
+                mutable_centers_view);
+        cuvs::neighbors::ivf_pq::helpers::rotate_padded_centers(
+                raft_handle,
+                cuvs_index->centers(),
+                cuvs_index->rotation_matrix(),
+                mutable_centers_rot_view);
     }

     setPQCentroids_();
diff --git a/faiss/gpu/utils/CuvsUtils.h b/faiss/gpu/utils/CuvsUtils.h
index e44e5f12d..42fe8ca48 100644
--- a/faiss/gpu/utils/CuvsUtils.h
+++ b/faiss/gpu/utils/CuvsUtils.h
@@ -27,32 +27,32 @@
 #include <faiss/gpu/GpuResources.h>
 #include <faiss/gpu/utils/Tensor.cuh>

-#include <cuvs/distance/distance.h>
+#include <cuvs/distance/distance.hpp>

 #pragma GCC visibility push(default)
 namespace faiss {
 namespace gpu {

-inline cuvsDistanceType metricFaissToCuvs(
+inline cuvs::distance::DistanceType metricFaissToCuvs(
         MetricType metric,
         bool exactDistance) {
     switch (metric) {
         case MetricType::METRIC_INNER_PRODUCT:
-            return cuvsDistanceType::InnerProduct;
+            return cuvs::distance::DistanceType::InnerProduct;
         case MetricType::METRIC_L2:
-            return cuvsDistanceType::L2Expanded;
+            return cuvs::distance::DistanceType::L2Expanded;
         case MetricType::METRIC_L1:
-            return cuvsDistanceType::L1;
+            return cuvs::distance::DistanceType::L1;
         case MetricType::METRIC_Linf:
-            return cuvsDistanceType::Linf;
+            return cuvs::distance::DistanceType::Linf;
         case MetricType::METRIC_Lp:
-            return cuvsDistanceType::LpUnexpanded;
+            return cuvs::distance::DistanceType::LpUnexpanded;
         case MetricType::METRIC_Canberra:
-            return cuvsDistanceType::Canberra;
+            return cuvs::distance::DistanceType::Canberra;
         case MetricType::METRIC_BrayCurtis:
-            return cuvsDistanceType::BrayCurtis;
+            return cuvs::distance::DistanceType::BrayCurtis;
         case MetricType::METRIC_JensenShannon:
-            return cuvsDistanceType::JensenShannon;
+            return cuvs::distance::DistanceType::JensenShannon;
         default:
             RAFT_FAIL("Distance type not supported");
     }
