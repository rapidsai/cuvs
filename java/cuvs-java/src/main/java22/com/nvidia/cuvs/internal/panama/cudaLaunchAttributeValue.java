/*
 * Copyright (c) 2025, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// NOTE: PLEASE DO NOT EDIT THIS FILE MANUALLY
// Generated by jextract

package com.nvidia.cuvs.internal.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * union cudaLaunchAttributeValue {
 *     char pad[64];
 *     struct cudaAccessPolicyWindow accessPolicyWindow;
 *     int cooperative;
 *     enum cudaSynchronizationPolicy syncPolicy;
 *     struct {
 *         unsigned int x;
 *         unsigned int y;
 *         unsigned int z;
 *     } clusterDim;
 *     enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference;
 *     int programmaticStreamSerializationAllowed;
 *     struct {
 *         cudaEvent_t event;
 *         int flags;
 *         int triggerAtBlockStart;
 *     } programmaticEvent;
 *     int priority;
 *     cudaLaunchMemSyncDomainMap memSyncDomainMap;
 *     cudaLaunchMemSyncDomain memSyncDomain;
 *     struct {
 *         cudaEvent_t event;
 *         int flags;
 *     } launchCompletionEvent;
 *     struct {
 *         int deviceUpdatable;
 *         cudaGraphDeviceNode_t devNode;
 *     } deviceUpdatableKernelNode;
 *     unsigned int sharedMemCarveout;
 * }
 * }
 */
public class cudaLaunchAttributeValue {

    cudaLaunchAttributeValue() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
        MemoryLayout.sequenceLayout(64, PanamaFFMAPI.C_CHAR).withName("pad"),
        cudaAccessPolicyWindow.layout().withName("accessPolicyWindow"),
        PanamaFFMAPI.C_INT.withName("cooperative"),
        PanamaFFMAPI.C_INT.withName("syncPolicy"),
        cudaLaunchAttributeValue.clusterDim.layout().withName("clusterDim"),
        PanamaFFMAPI.C_INT.withName("clusterSchedulingPolicyPreference"),
        PanamaFFMAPI.C_INT.withName("programmaticStreamSerializationAllowed"),
        cudaLaunchAttributeValue.programmaticEvent.layout().withName("programmaticEvent"),
        PanamaFFMAPI.C_INT.withName("priority"),
        cudaLaunchMemSyncDomainMap_st.layout().withName("memSyncDomainMap"),
        PanamaFFMAPI.C_INT.withName("memSyncDomain"),
        cudaLaunchAttributeValue.launchCompletionEvent.layout().withName("launchCompletionEvent"),
        cudaLaunchAttributeValue.deviceUpdatableKernelNode.layout().withName("deviceUpdatableKernelNode"),
        PanamaFFMAPI.C_INT.withName("sharedMemCarveout")
    ).withName("cudaLaunchAttributeValue");

    /**
     * The layout of this union
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final SequenceLayout pad$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("pad"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static final SequenceLayout pad$layout() {
        return pad$LAYOUT;
    }

    private static final long pad$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static final long pad$offset() {
        return pad$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static MemorySegment pad(MemorySegment union) {
        return union.asSlice(pad$OFFSET, pad$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static void pad(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, pad$OFFSET, pad$LAYOUT.byteSize());
    }

    private static long[] pad$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static long[] pad$dimensions() {
        return pad$DIMS;
    }
    private static final VarHandle pad$ELEM_HANDLE = pad$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static byte pad(MemorySegment union, long index0) {
        return (byte)pad$ELEM_HANDLE.get(union, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char pad[64]
     * }
     */
    public static void pad(MemorySegment union, long index0, byte fieldValue) {
        pad$ELEM_HANDLE.set(union, 0L, index0, fieldValue);
    }

    private static final GroupLayout accessPolicyWindow$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("accessPolicyWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct cudaAccessPolicyWindow accessPolicyWindow
     * }
     */
    public static final GroupLayout accessPolicyWindow$layout() {
        return accessPolicyWindow$LAYOUT;
    }

    private static final long accessPolicyWindow$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct cudaAccessPolicyWindow accessPolicyWindow
     * }
     */
    public static final long accessPolicyWindow$offset() {
        return accessPolicyWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct cudaAccessPolicyWindow accessPolicyWindow
     * }
     */
    public static MemorySegment accessPolicyWindow(MemorySegment union) {
        return union.asSlice(accessPolicyWindow$OFFSET, accessPolicyWindow$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct cudaAccessPolicyWindow accessPolicyWindow
     * }
     */
    public static void accessPolicyWindow(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, accessPolicyWindow$OFFSET, accessPolicyWindow$LAYOUT.byteSize());
    }

    private static final OfInt cooperative$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cooperative"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int cooperative
     * }
     */
    public static final OfInt cooperative$layout() {
        return cooperative$LAYOUT;
    }

    private static final long cooperative$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int cooperative
     * }
     */
    public static final long cooperative$offset() {
        return cooperative$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int cooperative
     * }
     */
    public static int cooperative(MemorySegment union) {
        return union.get(cooperative$LAYOUT, cooperative$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int cooperative
     * }
     */
    public static void cooperative(MemorySegment union, int fieldValue) {
        union.set(cooperative$LAYOUT, cooperative$OFFSET, fieldValue);
    }

    private static final OfInt syncPolicy$LAYOUT = (OfInt)$LAYOUT.select(groupElement("syncPolicy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum cudaSynchronizationPolicy syncPolicy
     * }
     */
    public static final OfInt syncPolicy$layout() {
        return syncPolicy$LAYOUT;
    }

    private static final long syncPolicy$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum cudaSynchronizationPolicy syncPolicy
     * }
     */
    public static final long syncPolicy$offset() {
        return syncPolicy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum cudaSynchronizationPolicy syncPolicy
     * }
     */
    public static int syncPolicy(MemorySegment union) {
        return union.get(syncPolicy$LAYOUT, syncPolicy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum cudaSynchronizationPolicy syncPolicy
     * }
     */
    public static void syncPolicy(MemorySegment union, int fieldValue) {
        union.set(syncPolicy$LAYOUT, syncPolicy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     unsigned int x;
     *     unsigned int y;
     *     unsigned int z;
     * }
     * }
     */
    public static class clusterDim {

        clusterDim() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            PanamaFFMAPI.C_INT.withName("x"),
            PanamaFFMAPI.C_INT.withName("y"),
            PanamaFFMAPI.C_INT.withName("z")
        ).withName("$anon$3544:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt x$LAYOUT = (OfInt)$LAYOUT.select(groupElement("x"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * unsigned int x
         * }
         */
        public static final OfInt x$layout() {
            return x$LAYOUT;
        }

        private static final long x$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * unsigned int x
         * }
         */
        public static final long x$offset() {
            return x$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * unsigned int x
         * }
         */
        public static int x(MemorySegment struct) {
            return struct.get(x$LAYOUT, x$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * unsigned int x
         * }
         */
        public static void x(MemorySegment struct, int fieldValue) {
            struct.set(x$LAYOUT, x$OFFSET, fieldValue);
        }

        private static final OfInt y$LAYOUT = (OfInt)$LAYOUT.select(groupElement("y"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * unsigned int y
         * }
         */
        public static final OfInt y$layout() {
            return y$LAYOUT;
        }

        private static final long y$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * unsigned int y
         * }
         */
        public static final long y$offset() {
            return y$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * unsigned int y
         * }
         */
        public static int y(MemorySegment struct) {
            return struct.get(y$LAYOUT, y$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * unsigned int y
         * }
         */
        public static void y(MemorySegment struct, int fieldValue) {
            struct.set(y$LAYOUT, y$OFFSET, fieldValue);
        }

        private static final OfInt z$LAYOUT = (OfInt)$LAYOUT.select(groupElement("z"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * unsigned int z
         * }
         */
        public static final OfInt z$layout() {
            return z$LAYOUT;
        }

        private static final long z$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * unsigned int z
         * }
         */
        public static final long z$offset() {
            return z$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * unsigned int z
         * }
         */
        public static int z(MemorySegment struct) {
            return struct.get(z$LAYOUT, z$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * unsigned int z
         * }
         */
        public static void z(MemorySegment struct, int fieldValue) {
            struct.set(z$LAYOUT, z$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout clusterDim$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("clusterDim"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     unsigned int x;
     *     unsigned int y;
     *     unsigned int z;
     * } clusterDim
     * }
     */
    public static final GroupLayout clusterDim$layout() {
        return clusterDim$LAYOUT;
    }

    private static final long clusterDim$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     unsigned int x;
     *     unsigned int y;
     *     unsigned int z;
     * } clusterDim
     * }
     */
    public static final long clusterDim$offset() {
        return clusterDim$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     unsigned int x;
     *     unsigned int y;
     *     unsigned int z;
     * } clusterDim
     * }
     */
    public static MemorySegment clusterDim(MemorySegment union) {
        return union.asSlice(clusterDim$OFFSET, clusterDim$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     unsigned int x;
     *     unsigned int y;
     *     unsigned int z;
     * } clusterDim
     * }
     */
    public static void clusterDim(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, clusterDim$OFFSET, clusterDim$LAYOUT.byteSize());
    }

    private static final OfInt clusterSchedulingPolicyPreference$LAYOUT = (OfInt)$LAYOUT.select(groupElement("clusterSchedulingPolicyPreference"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference
     * }
     */
    public static final OfInt clusterSchedulingPolicyPreference$layout() {
        return clusterSchedulingPolicyPreference$LAYOUT;
    }

    private static final long clusterSchedulingPolicyPreference$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference
     * }
     */
    public static final long clusterSchedulingPolicyPreference$offset() {
        return clusterSchedulingPolicyPreference$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference
     * }
     */
    public static int clusterSchedulingPolicyPreference(MemorySegment union) {
        return union.get(clusterSchedulingPolicyPreference$LAYOUT, clusterSchedulingPolicyPreference$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference
     * }
     */
    public static void clusterSchedulingPolicyPreference(MemorySegment union, int fieldValue) {
        union.set(clusterSchedulingPolicyPreference$LAYOUT, clusterSchedulingPolicyPreference$OFFSET, fieldValue);
    }

    private static final OfInt programmaticStreamSerializationAllowed$LAYOUT = (OfInt)$LAYOUT.select(groupElement("programmaticStreamSerializationAllowed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int programmaticStreamSerializationAllowed
     * }
     */
    public static final OfInt programmaticStreamSerializationAllowed$layout() {
        return programmaticStreamSerializationAllowed$LAYOUT;
    }

    private static final long programmaticStreamSerializationAllowed$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int programmaticStreamSerializationAllowed
     * }
     */
    public static final long programmaticStreamSerializationAllowed$offset() {
        return programmaticStreamSerializationAllowed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int programmaticStreamSerializationAllowed
     * }
     */
    public static int programmaticStreamSerializationAllowed(MemorySegment union) {
        return union.get(programmaticStreamSerializationAllowed$LAYOUT, programmaticStreamSerializationAllowed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int programmaticStreamSerializationAllowed
     * }
     */
    public static void programmaticStreamSerializationAllowed(MemorySegment union, int fieldValue) {
        union.set(programmaticStreamSerializationAllowed$LAYOUT, programmaticStreamSerializationAllowed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     *     int triggerAtBlockStart;
     * }
     * }
     */
    public static class programmaticEvent {

        programmaticEvent() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            PanamaFFMAPI.C_POINTER.withName("event"),
            PanamaFFMAPI.C_INT.withName("flags"),
            PanamaFFMAPI.C_INT.withName("triggerAtBlockStart")
        ).withName("$anon$3563:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("event"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static final AddressLayout event$layout() {
            return event$LAYOUT;
        }

        private static final long event$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static final long event$offset() {
            return event$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static MemorySegment event(MemorySegment struct) {
            return struct.get(event$LAYOUT, event$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static void event(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(event$LAYOUT, event$OFFSET, fieldValue);
        }

        private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static final OfInt flags$layout() {
            return flags$LAYOUT;
        }

        private static final long flags$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static final long flags$offset() {
            return flags$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static int flags(MemorySegment struct) {
            return struct.get(flags$LAYOUT, flags$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static void flags(MemorySegment struct, int fieldValue) {
            struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
        }

        private static final OfInt triggerAtBlockStart$LAYOUT = (OfInt)$LAYOUT.select(groupElement("triggerAtBlockStart"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int triggerAtBlockStart
         * }
         */
        public static final OfInt triggerAtBlockStart$layout() {
            return triggerAtBlockStart$LAYOUT;
        }

        private static final long triggerAtBlockStart$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int triggerAtBlockStart
         * }
         */
        public static final long triggerAtBlockStart$offset() {
            return triggerAtBlockStart$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int triggerAtBlockStart
         * }
         */
        public static int triggerAtBlockStart(MemorySegment struct) {
            return struct.get(triggerAtBlockStart$LAYOUT, triggerAtBlockStart$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int triggerAtBlockStart
         * }
         */
        public static void triggerAtBlockStart(MemorySegment struct, int fieldValue) {
            struct.set(triggerAtBlockStart$LAYOUT, triggerAtBlockStart$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout programmaticEvent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("programmaticEvent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     *     int triggerAtBlockStart;
     * } programmaticEvent
     * }
     */
    public static final GroupLayout programmaticEvent$layout() {
        return programmaticEvent$LAYOUT;
    }

    private static final long programmaticEvent$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     *     int triggerAtBlockStart;
     * } programmaticEvent
     * }
     */
    public static final long programmaticEvent$offset() {
        return programmaticEvent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     *     int triggerAtBlockStart;
     * } programmaticEvent
     * }
     */
    public static MemorySegment programmaticEvent(MemorySegment union) {
        return union.asSlice(programmaticEvent$OFFSET, programmaticEvent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     *     int triggerAtBlockStart;
     * } programmaticEvent
     * }
     */
    public static void programmaticEvent(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, programmaticEvent$OFFSET, programmaticEvent$LAYOUT.byteSize());
    }

    private static final OfInt priority$LAYOUT = (OfInt)$LAYOUT.select(groupElement("priority"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int priority
     * }
     */
    public static final OfInt priority$layout() {
        return priority$LAYOUT;
    }

    private static final long priority$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int priority
     * }
     */
    public static final long priority$offset() {
        return priority$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int priority
     * }
     */
    public static int priority(MemorySegment union) {
        return union.get(priority$LAYOUT, priority$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int priority
     * }
     */
    public static void priority(MemorySegment union, int fieldValue) {
        union.set(priority$LAYOUT, priority$OFFSET, fieldValue);
    }

    private static final GroupLayout memSyncDomainMap$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("memSyncDomainMap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomainMap memSyncDomainMap
     * }
     */
    public static final GroupLayout memSyncDomainMap$layout() {
        return memSyncDomainMap$LAYOUT;
    }

    private static final long memSyncDomainMap$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomainMap memSyncDomainMap
     * }
     */
    public static final long memSyncDomainMap$offset() {
        return memSyncDomainMap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomainMap memSyncDomainMap
     * }
     */
    public static MemorySegment memSyncDomainMap(MemorySegment union) {
        return union.asSlice(memSyncDomainMap$OFFSET, memSyncDomainMap$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomainMap memSyncDomainMap
     * }
     */
    public static void memSyncDomainMap(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, memSyncDomainMap$OFFSET, memSyncDomainMap$LAYOUT.byteSize());
    }

    private static final OfInt memSyncDomain$LAYOUT = (OfInt)$LAYOUT.select(groupElement("memSyncDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomain memSyncDomain
     * }
     */
    public static final OfInt memSyncDomain$layout() {
        return memSyncDomain$LAYOUT;
    }

    private static final long memSyncDomain$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomain memSyncDomain
     * }
     */
    public static final long memSyncDomain$offset() {
        return memSyncDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomain memSyncDomain
     * }
     */
    public static int memSyncDomain(MemorySegment union) {
        return union.get(memSyncDomain$LAYOUT, memSyncDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cudaLaunchMemSyncDomain memSyncDomain
     * }
     */
    public static void memSyncDomain(MemorySegment union, int fieldValue) {
        union.set(memSyncDomain$LAYOUT, memSyncDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     * }
     * }
     */
    public static class launchCompletionEvent {

        launchCompletionEvent() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            PanamaFFMAPI.C_POINTER.withName("event"),
            PanamaFFMAPI.C_INT.withName("flags"),
            MemoryLayout.paddingLayout(4)
        ).withName("$anon$3581:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("event"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static final AddressLayout event$layout() {
            return event$LAYOUT;
        }

        private static final long event$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static final long event$offset() {
            return event$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static MemorySegment event(MemorySegment struct) {
            return struct.get(event$LAYOUT, event$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * cudaEvent_t event
         * }
         */
        public static void event(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(event$LAYOUT, event$OFFSET, fieldValue);
        }

        private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static final OfInt flags$layout() {
            return flags$LAYOUT;
        }

        private static final long flags$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static final long flags$offset() {
            return flags$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static int flags(MemorySegment struct) {
            return struct.get(flags$LAYOUT, flags$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int flags
         * }
         */
        public static void flags(MemorySegment struct, int fieldValue) {
            struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout launchCompletionEvent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("launchCompletionEvent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     * } launchCompletionEvent
     * }
     */
    public static final GroupLayout launchCompletionEvent$layout() {
        return launchCompletionEvent$LAYOUT;
    }

    private static final long launchCompletionEvent$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     * } launchCompletionEvent
     * }
     */
    public static final long launchCompletionEvent$offset() {
        return launchCompletionEvent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     * } launchCompletionEvent
     * }
     */
    public static MemorySegment launchCompletionEvent(MemorySegment union) {
        return union.asSlice(launchCompletionEvent$OFFSET, launchCompletionEvent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     cudaEvent_t event;
     *     int flags;
     * } launchCompletionEvent
     * }
     */
    public static void launchCompletionEvent(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, launchCompletionEvent$OFFSET, launchCompletionEvent$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     int deviceUpdatable;
     *     cudaGraphDeviceNode_t devNode;
     * }
     * }
     */
    public static class deviceUpdatableKernelNode {

        deviceUpdatableKernelNode() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            PanamaFFMAPI.C_INT.withName("deviceUpdatable"),
            MemoryLayout.paddingLayout(4),
            PanamaFFMAPI.C_POINTER.withName("devNode")
        ).withName("$anon$3592:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt deviceUpdatable$LAYOUT = (OfInt)$LAYOUT.select(groupElement("deviceUpdatable"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int deviceUpdatable
         * }
         */
        public static final OfInt deviceUpdatable$layout() {
            return deviceUpdatable$LAYOUT;
        }

        private static final long deviceUpdatable$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int deviceUpdatable
         * }
         */
        public static final long deviceUpdatable$offset() {
            return deviceUpdatable$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int deviceUpdatable
         * }
         */
        public static int deviceUpdatable(MemorySegment struct) {
            return struct.get(deviceUpdatable$LAYOUT, deviceUpdatable$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int deviceUpdatable
         * }
         */
        public static void deviceUpdatable(MemorySegment struct, int fieldValue) {
            struct.set(deviceUpdatable$LAYOUT, deviceUpdatable$OFFSET, fieldValue);
        }

        private static final AddressLayout devNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("devNode"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * cudaGraphDeviceNode_t devNode
         * }
         */
        public static final AddressLayout devNode$layout() {
            return devNode$LAYOUT;
        }

        private static final long devNode$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * cudaGraphDeviceNode_t devNode
         * }
         */
        public static final long devNode$offset() {
            return devNode$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * cudaGraphDeviceNode_t devNode
         * }
         */
        public static MemorySegment devNode(MemorySegment struct) {
            return struct.get(devNode$LAYOUT, devNode$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * cudaGraphDeviceNode_t devNode
         * }
         */
        public static void devNode(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(devNode$LAYOUT, devNode$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout deviceUpdatableKernelNode$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("deviceUpdatableKernelNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     int deviceUpdatable;
     *     cudaGraphDeviceNode_t devNode;
     * } deviceUpdatableKernelNode
     * }
     */
    public static final GroupLayout deviceUpdatableKernelNode$layout() {
        return deviceUpdatableKernelNode$LAYOUT;
    }

    private static final long deviceUpdatableKernelNode$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     int deviceUpdatable;
     *     cudaGraphDeviceNode_t devNode;
     * } deviceUpdatableKernelNode
     * }
     */
    public static final long deviceUpdatableKernelNode$offset() {
        return deviceUpdatableKernelNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     int deviceUpdatable;
     *     cudaGraphDeviceNode_t devNode;
     * } deviceUpdatableKernelNode
     * }
     */
    public static MemorySegment deviceUpdatableKernelNode(MemorySegment union) {
        return union.asSlice(deviceUpdatableKernelNode$OFFSET, deviceUpdatableKernelNode$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     int deviceUpdatable;
     *     cudaGraphDeviceNode_t devNode;
     * } deviceUpdatableKernelNode
     * }
     */
    public static void deviceUpdatableKernelNode(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, deviceUpdatableKernelNode$OFFSET, deviceUpdatableKernelNode$LAYOUT.byteSize());
    }

    private static final OfInt sharedMemCarveout$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sharedMemCarveout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int sharedMemCarveout
     * }
     */
    public static final OfInt sharedMemCarveout$layout() {
        return sharedMemCarveout$LAYOUT;
    }

    private static final long sharedMemCarveout$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int sharedMemCarveout
     * }
     */
    public static final long sharedMemCarveout$offset() {
        return sharedMemCarveout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int sharedMemCarveout
     * }
     */
    public static int sharedMemCarveout(MemorySegment union) {
        return union.get(sharedMemCarveout$LAYOUT, sharedMemCarveout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int sharedMemCarveout
     * }
     */
    public static void sharedMemCarveout(MemorySegment union, int fieldValue) {
        union.set(sharedMemCarveout$LAYOUT, sharedMemCarveout$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this union
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
