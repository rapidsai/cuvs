/*
 * Copyright (c) 2025, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// NOTE: PLEASE DO NOT EDIT THIS FILE MANUALLY
// Generated by jextract

package com.nvidia.cuvs.internal.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct cudaFuncAttributes {
 *     size_t sharedSizeBytes;
 *     size_t constSizeBytes;
 *     size_t localSizeBytes;
 *     int maxThreadsPerBlock;
 *     int numRegs;
 *     int ptxVersion;
 *     int binaryVersion;
 *     int cacheModeCA;
 *     int maxDynamicSharedSizeBytes;
 *     int preferredShmemCarveout;
 *     int clusterDimMustBeSet;
 *     int requiredClusterWidth;
 *     int requiredClusterHeight;
 *     int requiredClusterDepth;
 *     int clusterSchedulingPolicyPreference;
 *     int nonPortableClusterSizeAllowed;
 *     int reserved[16];
 * }
 * }
 */
public class cudaFuncAttributes {

    cudaFuncAttributes() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        PanamaFFMAPI.C_LONG.withName("sharedSizeBytes"),
        PanamaFFMAPI.C_LONG.withName("constSizeBytes"),
        PanamaFFMAPI.C_LONG.withName("localSizeBytes"),
        PanamaFFMAPI.C_INT.withName("maxThreadsPerBlock"),
        PanamaFFMAPI.C_INT.withName("numRegs"),
        PanamaFFMAPI.C_INT.withName("ptxVersion"),
        PanamaFFMAPI.C_INT.withName("binaryVersion"),
        PanamaFFMAPI.C_INT.withName("cacheModeCA"),
        PanamaFFMAPI.C_INT.withName("maxDynamicSharedSizeBytes"),
        PanamaFFMAPI.C_INT.withName("preferredShmemCarveout"),
        PanamaFFMAPI.C_INT.withName("clusterDimMustBeSet"),
        PanamaFFMAPI.C_INT.withName("requiredClusterWidth"),
        PanamaFFMAPI.C_INT.withName("requiredClusterHeight"),
        PanamaFFMAPI.C_INT.withName("requiredClusterDepth"),
        PanamaFFMAPI.C_INT.withName("clusterSchedulingPolicyPreference"),
        PanamaFFMAPI.C_INT.withName("nonPortableClusterSizeAllowed"),
        MemoryLayout.sequenceLayout(16, PanamaFFMAPI.C_INT).withName("reserved"),
        MemoryLayout.paddingLayout(4)
    ).withName("cudaFuncAttributes");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfLong sharedSizeBytes$LAYOUT = (OfLong)$LAYOUT.select(groupElement("sharedSizeBytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t sharedSizeBytes
     * }
     */
    public static final OfLong sharedSizeBytes$layout() {
        return sharedSizeBytes$LAYOUT;
    }

    private static final long sharedSizeBytes$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t sharedSizeBytes
     * }
     */
    public static final long sharedSizeBytes$offset() {
        return sharedSizeBytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t sharedSizeBytes
     * }
     */
    public static long sharedSizeBytes(MemorySegment struct) {
        return struct.get(sharedSizeBytes$LAYOUT, sharedSizeBytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t sharedSizeBytes
     * }
     */
    public static void sharedSizeBytes(MemorySegment struct, long fieldValue) {
        struct.set(sharedSizeBytes$LAYOUT, sharedSizeBytes$OFFSET, fieldValue);
    }

    private static final OfLong constSizeBytes$LAYOUT = (OfLong)$LAYOUT.select(groupElement("constSizeBytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t constSizeBytes
     * }
     */
    public static final OfLong constSizeBytes$layout() {
        return constSizeBytes$LAYOUT;
    }

    private static final long constSizeBytes$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t constSizeBytes
     * }
     */
    public static final long constSizeBytes$offset() {
        return constSizeBytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t constSizeBytes
     * }
     */
    public static long constSizeBytes(MemorySegment struct) {
        return struct.get(constSizeBytes$LAYOUT, constSizeBytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t constSizeBytes
     * }
     */
    public static void constSizeBytes(MemorySegment struct, long fieldValue) {
        struct.set(constSizeBytes$LAYOUT, constSizeBytes$OFFSET, fieldValue);
    }

    private static final OfLong localSizeBytes$LAYOUT = (OfLong)$LAYOUT.select(groupElement("localSizeBytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t localSizeBytes
     * }
     */
    public static final OfLong localSizeBytes$layout() {
        return localSizeBytes$LAYOUT;
    }

    private static final long localSizeBytes$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t localSizeBytes
     * }
     */
    public static final long localSizeBytes$offset() {
        return localSizeBytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t localSizeBytes
     * }
     */
    public static long localSizeBytes(MemorySegment struct) {
        return struct.get(localSizeBytes$LAYOUT, localSizeBytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t localSizeBytes
     * }
     */
    public static void localSizeBytes(MemorySegment struct, long fieldValue) {
        struct.set(localSizeBytes$LAYOUT, localSizeBytes$OFFSET, fieldValue);
    }

    private static final OfInt maxThreadsPerBlock$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxThreadsPerBlock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxThreadsPerBlock
     * }
     */
    public static final OfInt maxThreadsPerBlock$layout() {
        return maxThreadsPerBlock$LAYOUT;
    }

    private static final long maxThreadsPerBlock$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxThreadsPerBlock
     * }
     */
    public static final long maxThreadsPerBlock$offset() {
        return maxThreadsPerBlock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxThreadsPerBlock
     * }
     */
    public static int maxThreadsPerBlock(MemorySegment struct) {
        return struct.get(maxThreadsPerBlock$LAYOUT, maxThreadsPerBlock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxThreadsPerBlock
     * }
     */
    public static void maxThreadsPerBlock(MemorySegment struct, int fieldValue) {
        struct.set(maxThreadsPerBlock$LAYOUT, maxThreadsPerBlock$OFFSET, fieldValue);
    }

    private static final OfInt numRegs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numRegs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numRegs
     * }
     */
    public static final OfInt numRegs$layout() {
        return numRegs$LAYOUT;
    }

    private static final long numRegs$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numRegs
     * }
     */
    public static final long numRegs$offset() {
        return numRegs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numRegs
     * }
     */
    public static int numRegs(MemorySegment struct) {
        return struct.get(numRegs$LAYOUT, numRegs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numRegs
     * }
     */
    public static void numRegs(MemorySegment struct, int fieldValue) {
        struct.set(numRegs$LAYOUT, numRegs$OFFSET, fieldValue);
    }

    private static final OfInt ptxVersion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ptxVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int ptxVersion
     * }
     */
    public static final OfInt ptxVersion$layout() {
        return ptxVersion$LAYOUT;
    }

    private static final long ptxVersion$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int ptxVersion
     * }
     */
    public static final long ptxVersion$offset() {
        return ptxVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int ptxVersion
     * }
     */
    public static int ptxVersion(MemorySegment struct) {
        return struct.get(ptxVersion$LAYOUT, ptxVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int ptxVersion
     * }
     */
    public static void ptxVersion(MemorySegment struct, int fieldValue) {
        struct.set(ptxVersion$LAYOUT, ptxVersion$OFFSET, fieldValue);
    }

    private static final OfInt binaryVersion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("binaryVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int binaryVersion
     * }
     */
    public static final OfInt binaryVersion$layout() {
        return binaryVersion$LAYOUT;
    }

    private static final long binaryVersion$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int binaryVersion
     * }
     */
    public static final long binaryVersion$offset() {
        return binaryVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int binaryVersion
     * }
     */
    public static int binaryVersion(MemorySegment struct) {
        return struct.get(binaryVersion$LAYOUT, binaryVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int binaryVersion
     * }
     */
    public static void binaryVersion(MemorySegment struct, int fieldValue) {
        struct.set(binaryVersion$LAYOUT, binaryVersion$OFFSET, fieldValue);
    }

    private static final OfInt cacheModeCA$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cacheModeCA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int cacheModeCA
     * }
     */
    public static final OfInt cacheModeCA$layout() {
        return cacheModeCA$LAYOUT;
    }

    private static final long cacheModeCA$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int cacheModeCA
     * }
     */
    public static final long cacheModeCA$offset() {
        return cacheModeCA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int cacheModeCA
     * }
     */
    public static int cacheModeCA(MemorySegment struct) {
        return struct.get(cacheModeCA$LAYOUT, cacheModeCA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int cacheModeCA
     * }
     */
    public static void cacheModeCA(MemorySegment struct, int fieldValue) {
        struct.set(cacheModeCA$LAYOUT, cacheModeCA$OFFSET, fieldValue);
    }

    private static final OfInt maxDynamicSharedSizeBytes$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxDynamicSharedSizeBytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxDynamicSharedSizeBytes
     * }
     */
    public static final OfInt maxDynamicSharedSizeBytes$layout() {
        return maxDynamicSharedSizeBytes$LAYOUT;
    }

    private static final long maxDynamicSharedSizeBytes$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxDynamicSharedSizeBytes
     * }
     */
    public static final long maxDynamicSharedSizeBytes$offset() {
        return maxDynamicSharedSizeBytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxDynamicSharedSizeBytes
     * }
     */
    public static int maxDynamicSharedSizeBytes(MemorySegment struct) {
        return struct.get(maxDynamicSharedSizeBytes$LAYOUT, maxDynamicSharedSizeBytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxDynamicSharedSizeBytes
     * }
     */
    public static void maxDynamicSharedSizeBytes(MemorySegment struct, int fieldValue) {
        struct.set(maxDynamicSharedSizeBytes$LAYOUT, maxDynamicSharedSizeBytes$OFFSET, fieldValue);
    }

    private static final OfInt preferredShmemCarveout$LAYOUT = (OfInt)$LAYOUT.select(groupElement("preferredShmemCarveout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int preferredShmemCarveout
     * }
     */
    public static final OfInt preferredShmemCarveout$layout() {
        return preferredShmemCarveout$LAYOUT;
    }

    private static final long preferredShmemCarveout$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int preferredShmemCarveout
     * }
     */
    public static final long preferredShmemCarveout$offset() {
        return preferredShmemCarveout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int preferredShmemCarveout
     * }
     */
    public static int preferredShmemCarveout(MemorySegment struct) {
        return struct.get(preferredShmemCarveout$LAYOUT, preferredShmemCarveout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int preferredShmemCarveout
     * }
     */
    public static void preferredShmemCarveout(MemorySegment struct, int fieldValue) {
        struct.set(preferredShmemCarveout$LAYOUT, preferredShmemCarveout$OFFSET, fieldValue);
    }

    private static final OfInt clusterDimMustBeSet$LAYOUT = (OfInt)$LAYOUT.select(groupElement("clusterDimMustBeSet"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int clusterDimMustBeSet
     * }
     */
    public static final OfInt clusterDimMustBeSet$layout() {
        return clusterDimMustBeSet$LAYOUT;
    }

    private static final long clusterDimMustBeSet$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int clusterDimMustBeSet
     * }
     */
    public static final long clusterDimMustBeSet$offset() {
        return clusterDimMustBeSet$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int clusterDimMustBeSet
     * }
     */
    public static int clusterDimMustBeSet(MemorySegment struct) {
        return struct.get(clusterDimMustBeSet$LAYOUT, clusterDimMustBeSet$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int clusterDimMustBeSet
     * }
     */
    public static void clusterDimMustBeSet(MemorySegment struct, int fieldValue) {
        struct.set(clusterDimMustBeSet$LAYOUT, clusterDimMustBeSet$OFFSET, fieldValue);
    }

    private static final OfInt requiredClusterWidth$LAYOUT = (OfInt)$LAYOUT.select(groupElement("requiredClusterWidth"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int requiredClusterWidth
     * }
     */
    public static final OfInt requiredClusterWidth$layout() {
        return requiredClusterWidth$LAYOUT;
    }

    private static final long requiredClusterWidth$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int requiredClusterWidth
     * }
     */
    public static final long requiredClusterWidth$offset() {
        return requiredClusterWidth$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int requiredClusterWidth
     * }
     */
    public static int requiredClusterWidth(MemorySegment struct) {
        return struct.get(requiredClusterWidth$LAYOUT, requiredClusterWidth$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int requiredClusterWidth
     * }
     */
    public static void requiredClusterWidth(MemorySegment struct, int fieldValue) {
        struct.set(requiredClusterWidth$LAYOUT, requiredClusterWidth$OFFSET, fieldValue);
    }

    private static final OfInt requiredClusterHeight$LAYOUT = (OfInt)$LAYOUT.select(groupElement("requiredClusterHeight"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int requiredClusterHeight
     * }
     */
    public static final OfInt requiredClusterHeight$layout() {
        return requiredClusterHeight$LAYOUT;
    }

    private static final long requiredClusterHeight$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int requiredClusterHeight
     * }
     */
    public static final long requiredClusterHeight$offset() {
        return requiredClusterHeight$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int requiredClusterHeight
     * }
     */
    public static int requiredClusterHeight(MemorySegment struct) {
        return struct.get(requiredClusterHeight$LAYOUT, requiredClusterHeight$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int requiredClusterHeight
     * }
     */
    public static void requiredClusterHeight(MemorySegment struct, int fieldValue) {
        struct.set(requiredClusterHeight$LAYOUT, requiredClusterHeight$OFFSET, fieldValue);
    }

    private static final OfInt requiredClusterDepth$LAYOUT = (OfInt)$LAYOUT.select(groupElement("requiredClusterDepth"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int requiredClusterDepth
     * }
     */
    public static final OfInt requiredClusterDepth$layout() {
        return requiredClusterDepth$LAYOUT;
    }

    private static final long requiredClusterDepth$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int requiredClusterDepth
     * }
     */
    public static final long requiredClusterDepth$offset() {
        return requiredClusterDepth$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int requiredClusterDepth
     * }
     */
    public static int requiredClusterDepth(MemorySegment struct) {
        return struct.get(requiredClusterDepth$LAYOUT, requiredClusterDepth$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int requiredClusterDepth
     * }
     */
    public static void requiredClusterDepth(MemorySegment struct, int fieldValue) {
        struct.set(requiredClusterDepth$LAYOUT, requiredClusterDepth$OFFSET, fieldValue);
    }

    private static final OfInt clusterSchedulingPolicyPreference$LAYOUT = (OfInt)$LAYOUT.select(groupElement("clusterSchedulingPolicyPreference"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int clusterSchedulingPolicyPreference
     * }
     */
    public static final OfInt clusterSchedulingPolicyPreference$layout() {
        return clusterSchedulingPolicyPreference$LAYOUT;
    }

    private static final long clusterSchedulingPolicyPreference$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int clusterSchedulingPolicyPreference
     * }
     */
    public static final long clusterSchedulingPolicyPreference$offset() {
        return clusterSchedulingPolicyPreference$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int clusterSchedulingPolicyPreference
     * }
     */
    public static int clusterSchedulingPolicyPreference(MemorySegment struct) {
        return struct.get(clusterSchedulingPolicyPreference$LAYOUT, clusterSchedulingPolicyPreference$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int clusterSchedulingPolicyPreference
     * }
     */
    public static void clusterSchedulingPolicyPreference(MemorySegment struct, int fieldValue) {
        struct.set(clusterSchedulingPolicyPreference$LAYOUT, clusterSchedulingPolicyPreference$OFFSET, fieldValue);
    }

    private static final OfInt nonPortableClusterSizeAllowed$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nonPortableClusterSizeAllowed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int nonPortableClusterSizeAllowed
     * }
     */
    public static final OfInt nonPortableClusterSizeAllowed$layout() {
        return nonPortableClusterSizeAllowed$LAYOUT;
    }

    private static final long nonPortableClusterSizeAllowed$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int nonPortableClusterSizeAllowed
     * }
     */
    public static final long nonPortableClusterSizeAllowed$offset() {
        return nonPortableClusterSizeAllowed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int nonPortableClusterSizeAllowed
     * }
     */
    public static int nonPortableClusterSizeAllowed(MemorySegment struct) {
        return struct.get(nonPortableClusterSizeAllowed$LAYOUT, nonPortableClusterSizeAllowed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int nonPortableClusterSizeAllowed
     * }
     */
    public static void nonPortableClusterSizeAllowed(MemorySegment struct, int fieldValue) {
        struct.set(nonPortableClusterSizeAllowed$LAYOUT, nonPortableClusterSizeAllowed$OFFSET, fieldValue);
    }

    private static final SequenceLayout reserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static final SequenceLayout reserved$layout() {
        return reserved$LAYOUT;
    }

    private static final long reserved$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static final long reserved$offset() {
        return reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static MemorySegment reserved(MemorySegment struct) {
        return struct.asSlice(reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static void reserved(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    private static long[] reserved$DIMS = { 16 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static long[] reserved$dimensions() {
        return reserved$DIMS;
    }
    private static final VarHandle reserved$ELEM_HANDLE = reserved$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static int reserved(MemorySegment struct, long index0) {
        return (int)reserved$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * int reserved[16]
     * }
     */
    public static void reserved(MemorySegment struct, long index0, int fieldValue) {
        reserved$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
